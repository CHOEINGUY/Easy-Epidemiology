"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwebpage"] = self["webpackChunkwebpage"] || []).push([["src_components_DataInputVirtualScroll_utils_dateTimeUtils_js"],{

/***/ "./src/components/DataInputVirtualScroll/utils/dateTimeUtils.js":
/*!**********************************************************************!*\
  !*** ./src/components/DataInputVirtualScroll/utils/dateTimeUtils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatDateTime: function() { return /* binding */ formatDateTime; },\n/* harmony export */   getCurrentDateTime: function() { return /* binding */ getCurrentDateTime; },\n/* harmony export */   getCurrentDateTimeObject: function() { return /* binding */ getCurrentDateTimeObject; },\n/* harmony export */   isEqualDateTime: function() { return /* binding */ isEqualDateTime; },\n/* harmony export */   isValidDate: function() { return /* binding */ isValidDate; },\n/* harmony export */   isValidDateTimeRange: function() { return /* binding */ isValidDateTimeRange; },\n/* harmony export */   isValidDateTimeString: function() { return /* binding */ isValidDateTimeString; },\n/* harmony export */   isValidTime: function() { return /* binding */ isValidTime; },\n/* harmony export */   normalizeDateTimeString: function() { return /* binding */ normalizeDateTimeString; },\n/* harmony export */   parseDateTime: function() { return /* binding */ parseDateTime; },\n/* harmony export */   tryParseUserInput: function() { return /* binding */ tryParseUserInput; }\n/* harmony export */ });\n/**\r\n * 날짜/시간 관련 유틸리티 함수들\r\n * yyyy-mm-dd hh:mm 형식을 기준으로 파싱 및 포맷팅\r\n */\n\n/**\r\n * yyyy-mm-dd hh:mm 형식의 문자열을 파싱하여 객체로 반환\r\n * @param {string} value - 파싱할 날짜/시간 문자열\r\n * @returns {object|null} - 파싱된 날짜/시간 객체 또는 null\r\n */\nfunction parseDateTime(value) {\n  if (!value || typeof value !== 'string') {\n    return null;\n  }\n\n  // yyyy-mm-dd hh:mm 형식 정규식\n  const dateTimeRegex = /^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2})$/;\n  const match = value.trim().match(dateTimeRegex);\n  if (!match) {\n    return null;\n  }\n  const year = parseInt(match[1]);\n  const month = parseInt(match[2]);\n  const day = parseInt(match[3]);\n  const hour = match[4]; // 문자열로 유지 (00-23)\n  const minute = match[5]; // 문자열로 유지 (00-59)\n\n  // 날짜 유효성 검증\n  if (!isValidDate(year, month, day)) {\n    return null;\n  }\n\n  // 시간 유효성 검증\n  if (!isValidTime(hour, minute)) {\n    return null;\n  }\n  return {\n    year,\n    month,\n    day,\n    hour,\n    minute\n  };\n}\n\n/**\r\n * 날짜/시간 객체를 yyyy-mm-dd hh:mm 형식 문자열로 포맷\r\n * @param {object} dateTime - 포맷할 날짜/시간 객체\r\n * @returns {string} - 포맷된 날짜/시간 문자열\r\n */\nfunction formatDateTime(dateTime) {\n  if (!dateTime || typeof dateTime !== 'object') {\n    return '';\n  }\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute\n  } = dateTime;\n\n  // 필수 필드 체크\n  if (!year || !month || !day || hour === undefined || minute === undefined) {\n    return '';\n  }\n\n  // 날짜 유효성 검증\n  if (!isValidDate(year, month, day)) {\n    return '';\n  }\n\n  // 시간 유효성 검증\n  if (!isValidTime(hour, minute)) {\n    return '';\n  }\n\n  // 포맷팅\n  const formattedMonth = String(month).padStart(2, '0');\n  const formattedDay = String(day).padStart(2, '0');\n  const formattedHour = String(hour).padStart(2, '0');\n  const formattedMinute = String(minute).padStart(2, '0');\n  return `${year}-${formattedMonth}-${formattedDay} ${formattedHour}:${formattedMinute}`;\n}\n\n/**\r\n * 날짜 유효성 검증\r\n * @param {number} year - 년도\r\n * @param {number} month - 월 (1-12)\r\n * @param {number} day - 일 (1-31)\r\n * @returns {boolean} - 유효한 날짜인지 여부\r\n */\nfunction isValidDate(year, month, day) {\n  // 범위 체크\n  if (year < 1900 || year > 2100) return false;\n  if (month < 1 || month > 12) return false;\n  if (day < 1 || day > 31) return false;\n\n  // JavaScript Date 객체로 실제 날짜 유효성 검증\n  const date = new Date(year, month - 1, day);\n  return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;\n}\n\n/**\r\n * 시간 유효성 검증\r\n * @param {string|number} hour - 시간 (0-23)\r\n * @param {string|number} minute - 분 (0-59)\r\n * @returns {boolean} - 유효한 시간인지 여부\r\n */\nfunction isValidTime(hour, minute) {\n  const hourNum = parseInt(hour);\n  const minuteNum = parseInt(minute);\n  return hourNum >= 0 && hourNum <= 23 && minuteNum >= 0 && minuteNum <= 59;\n}\n\n/**\r\n * 현재 날짜/시간을 yyyy-mm-dd hh:mm 형식으로 반환\r\n * @returns {string} - 현재 날짜/시간 문자열\r\n */\nfunction getCurrentDateTime() {\n  const now = new Date();\n  return formatDateTime({\n    year: now.getFullYear(),\n    month: now.getMonth() + 1,\n    day: now.getDate(),\n    hour: String(now.getHours()).padStart(2, '0'),\n    minute: String(now.getMinutes()).padStart(2, '0')\n  });\n}\n\n/**\r\n * 현재 날짜/시간 객체를 반환\r\n * @returns {object} - 현재 날짜/시간 객체\r\n */\nfunction getCurrentDateTimeObject() {\n  const now = new Date();\n  return {\n    year: now.getFullYear(),\n    month: now.getMonth() + 1,\n    day: now.getDate(),\n    hour: String(now.getHours()).padStart(2, '0'),\n    minute: String(now.getMinutes()).padStart(2, '0')\n  };\n}\n\n/**\r\n * 문자열이 유효한 날짜/시간 형식인지 검증\r\n * @param {string} value - 검증할 문자열\r\n * @returns {boolean} - 유효한 형식인지 여부\r\n */\nfunction isValidDateTimeString(value) {\n  const parsed = parseDateTime(value);\n  return parsed !== null;\n}\n\n/**\r\n * 날짜/시간 문자열을 정규화 (공백 정리 등)\r\n * @param {string} value - 정규화할 문자열\r\n * @returns {string} - 정규화된 문자열\r\n */\nfunction normalizeDateTimeString(value) {\n  if (!value || typeof value !== 'string') {\n    return '';\n  }\n\n  // 공백 정리\n  let normalized = value.trim();\n\n  // 여러 공백을 하나로 변환\n  normalized = normalized.replace(/\\s+/g, ' ');\n\n  // 파싱 후 다시 포맷 (유효한 경우)\n  const parsed = parseDateTime(normalized);\n  if (parsed) {\n    return formatDateTime(parsed);\n  }\n  return normalized;\n}\n\n/**\r\n * 두 날짜/시간이 같은지 비교\r\n * @param {string|object} dateTime1 - 첫 번째 날짜/시간\r\n * @param {string|object} dateTime2 - 두 번째 날짜/시간\r\n * @returns {boolean} - 같은지 여부\r\n */\nfunction isEqualDateTime(dateTime1, dateTime2) {\n  let obj1, obj2;\n\n  // 문자열인 경우 파싱\n  if (typeof dateTime1 === 'string') {\n    obj1 = parseDateTime(dateTime1);\n  } else {\n    obj1 = dateTime1;\n  }\n  if (typeof dateTime2 === 'string') {\n    obj2 = parseDateTime(dateTime2);\n  } else {\n    obj2 = dateTime2;\n  }\n\n  // 둘 다 null이거나 undefined인 경우\n  if (!obj1 && !obj2) return true;\n  if (!obj1 || !obj2) return false;\n  return obj1.year === obj2.year && obj1.month === obj2.month && obj1.day === obj2.day && obj1.hour === obj2.hour && obj1.minute === obj2.minute;\n}\n\n/**\r\n * 날짜/시간 범위 검증 (시작일 <= 종료일)\r\n * @param {string|object} startDateTime - 시작 날짜/시간\r\n * @param {string|object} endDateTime - 종료 날짜/시간\r\n * @returns {boolean} - 유효한 범위인지 여부\r\n */\nfunction isValidDateTimeRange(startDateTime, endDateTime) {\n  let start, end;\n\n  // 문자열인 경우 파싱\n  if (typeof startDateTime === 'string') {\n    start = parseDateTime(startDateTime);\n  } else {\n    start = startDateTime;\n  }\n  if (typeof endDateTime === 'string') {\n    end = parseDateTime(endDateTime);\n  } else {\n    end = endDateTime;\n  }\n  if (!start || !end) return false;\n\n  // Date 객체로 변환하여 비교\n  const startDate = new Date(start.year, start.month - 1, start.day, parseInt(start.hour), parseInt(start.minute));\n  const endDate = new Date(end.year, end.month - 1, end.day, parseInt(end.hour), parseInt(end.minute));\n  return startDate <= endDate;\n}\n\n/**\r\n * 사용자 입력 문자열을 날짜/시간 형식으로 변환 시도\r\n * 다양한 입력 형식을 지원\r\n * @param {string} input - 사용자 입력 문자열\r\n * @returns {string|null} - 변환된 날짜/시간 문자열 또는 null\r\n */\nfunction tryParseUserInput(input) {\n  if (!input || typeof input !== 'string') {\n    return null;\n  }\n  const cleanInput = input.trim();\n\n  // 이미 올바른 형식인 경우\n  if (isValidDateTimeString(cleanInput)) {\n    return cleanInput;\n  }\n\n  // 다양한 형식 시도\n  const patterns = [\n  // yyyy-mm-dd hh:mm:ss (초 무시)\n  /^(\\d{4})-(\\d{2})-(\\d{2})\\s+(\\d{2}):(\\d{2}):\\d{2}$/,\n  // yyyy/mm/dd hh:mm\n  /^(\\d{4})\\/(\\d{2})\\/(\\d{2})\\s+(\\d{2}):(\\d{2})$/,\n  // yyyy.mm.dd hh:mm\n  /^(\\d{4})\\.(\\d{2})\\.(\\d{2})\\s+(\\d{2}):(\\d{2})$/,\n  // yyyy-mm-dd (시간 없음, 00:00으로 설정)\n  /^(\\d{4})-(\\d{2})-(\\d{2})$/];\n  for (const pattern of patterns) {\n    const match = cleanInput.match(pattern);\n    if (match) {\n      const year = parseInt(match[1]);\n      const month = parseInt(match[2]);\n      const day = parseInt(match[3]);\n      const hour = match[4] ? match[4] : '00';\n      const minute = match[5] ? match[5] : '00';\n      if (isValidDate(year, month, day) && isValidTime(hour, minute)) {\n        return formatDateTime({\n          year,\n          month,\n          day,\n          hour,\n          minute\n        });\n      }\n    }\n  }\n  return null;\n}\n\n//# sourceURL=webpack://webpage/./src/components/DataInputVirtualScroll/utils/dateTimeUtils.js?\n}");

/***/ })

}]);